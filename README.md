<h2 align="center" >ğŸš€ Building a Classic: My CLI Snake Game! ğŸğŸ®</h2>
<p>"Ever tried controlling a snake in real time on Terminal without breaking the game? Well, I did... and it wasn't easy!"
Problem-solving, real-time movement, and efficient resource managementâ€”this project pushed my skills to the next level. Recreating the classic Snake game in a Linux terminal wasn't just about nostalgia; it was an exciting deep dive into game loops, non-blocking input handling, and real-time gameplay mechanics.</p>
<h3>Try the game:</h3>
<p>â€¢	Clone my repo.</p>
<p>â€¢	Run make.</p>
<p>â€¢	Run the generated game binary. Have fun!</p>
<h3>ğŸ”§ How It Works:</h3>
<p>âœ… Ncurses for Terminal UI â€“ Smooth rendering without flickering</p>
<p>âœ… Non-blocking Input Handling â€“ Capturing user input while the game runs</p>
<p>âœ… Game Loop Mechanics â€“ Constant updates for movement, collision, and growth</p>
<p>âœ… Dynamic Collision Detection â€“ Walls, self-hit, and food collection</p>
<p>âœ… Adjustable Speed â€“ Controlled by usleep() and timeout()</p>
<h3>ğŸ¯ Key Learnings:</h3>
<p>ğŸ”¹ Real-time Programming â€“ Handling inputs and updates asynchronously</p>
<p>ğŸ”¹ Memory & Performance Optimization â€“ Efficient use of arrays and structs</p>
<p>ğŸ”¹ Multiplayer Potential â€“ Laying the groundwork for networked gameplay</p>
<p>ğŸ”¹ Debugging Live Systems â€“ Handling unexpected user inputs and crashes</p>
<p>ğŸ”¹ Event-driven programming (how real-time systems process input)</p>
<p>ğŸ”¹ Low-latency input handling (useful in gaming & embedded systems)</p>
<p>ğŸ”¹ Memory-efficient game state management (critical for constrained systems)</p>

<p>This project was a fun yet challenging exercise in thinking ahead, managing resources, and optimizing performance.ğŸš€</p>
<p>â€œFrom blinking LEDs to moving snakesâ€”every project teaches us something new.â€</p>
