<h2 align="center" >🚀 Building a Classic: My CLI Snake Game! 🐍🎮</h2>
<p>"Ever tried controlling a snake in real time on Terminal without breaking the game? Well, I did... and it wasn't easy!"
Problem-solving, real-time movement, and efficient resource management—this project pushed my skills to the next level. Recreating the classic Snake game in a Linux terminal wasn't just about nostalgia; it was an exciting deep dive into game loops, non-blocking input handling, and real-time gameplay mechanics.</p>
<h3>Try the game:</h3>
<p>•	Clone my repo.</p>
<p>•	Run make.</p>
<p>•	Run the generated game binary. Have fun!</p>
<h3>🔧 How It Works:</h3>
<p>✅ Ncurses for Terminal UI – Smooth rendering without flickering</p>
<p>✅ Non-blocking Input Handling – Capturing user input while the game runs</p>
<p>✅ Game Loop Mechanics – Constant updates for movement, collision, and growth</p>
<p>✅ Dynamic Collision Detection – Walls, self-hit, and food collection</p>
<p>✅ Adjustable Speed – Controlled by usleep() and timeout()</p>
<h3>🎯 Key Learnings:</h3>
<p>🔹 Real-time Programming – Handling inputs and updates asynchronously</p>
<p>🔹 Memory & Performance Optimization – Efficient use of arrays and structs</p>
<p>🔹 Multiplayer Potential – Laying the groundwork for networked gameplay</p>
<p>🔹 Debugging Live Systems – Handling unexpected user inputs and crashes</p>
<p>🔹 Event-driven programming (how real-time systems process input)</p>
<p>🔹 Low-latency input handling (useful in gaming & embedded systems)</p>
<p>🔹 Memory-efficient game state management (critical for constrained systems)</p>

<p>This project was a fun yet challenging exercise in thinking ahead, managing resources, and optimizing performance.🚀</p>
<p>“From blinking LEDs to moving snakes—every project teaches us something new.”</p>
